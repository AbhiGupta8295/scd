#--------------------------remove extra unwanted permission from users----------------------
import boto3
from datetime import datetime, timedelta
import csv

# Create a session using boto3
iam_client = boto3.client('iam')
cloudtrail_client = boto3.client('cloudtrail')

# Define the time period for 3 months
time_threshold = datetime.utcnow() - timedelta(days=90)

# Get all IAM users
def list_users():
    users = []
    try:
        paginator = iam_client.get_paginator('list_users')
        for response in paginator.paginate():
            users.extend(response['Users'])
    except Exception as e:
        print(f"Error retrieving users: {str(e)}")
    return users

# List all roles assigned to a specific user (from policies or role assumptions)
def get_user_roles(user_name):
    roles = []
    try:
        # List attached user policies and look for roles within them
        response = iam_client.list_attached_user_policies(UserName=user_name)
        for policy in response['AttachedPolicies']:
            # Get policy document and check for role usage
            policy_arn = policy['PolicyArn']
            policy_doc = iam_client.get_policy_version(
                PolicyArn=policy_arn,
                VersionId=iam_client.get_policy(PolicyArn=policy_arn)['Policy']['DefaultVersionId']
            )
            # Check if the policy document allows any roles (this is a simplified check)
            if 'AssumeRole' in str(policy_doc):
                roles.append(policy_arn)  # Add the role if found
    except Exception as e:
        print(f"Error retrieving roles for user {user_name}: {str(e)}")
    return roles

# Get CloudTrail events for role usage
def get_role_usage(role_name):
    last_used = None
    frequency = 0
    try:
        # Search CloudTrail events for role assumption
        response = cloudtrail_client.lookup_events(
            LookupAttributes=[{'AttributeKey': 'EventName', 'AttributeValue': 'AssumeRole'}],
            StartTime=time_threshold,  # Limit to past 3 months
            EndTime=datetime.utcnow()
        )
        for event in response['Events']:
            if role_name in event['Resources']:
                event_time = event['EventTime']
                frequency += 1
                if not last_used or event_time > last_used:
                    last_used = event_time
    except Exception as e:
        print(f"Error retrieving CloudTrail events for role {role_name}: {str(e)}")
    return last_used, frequency

# Generate a report with user-role mapping, last usage, and frequency
def generate_user_role_report():
    report = []
    users = list_users()
    for user in users:
        user_name = user['UserName']
        user_roles = get_user_roles(user_name)
        for role in user_roles:
            last_used, frequency = get_role_usage(role)
            report.append({
                'UserName': user_name,
                'RoleName': role,
                'LastUsed': last_used or 'Never',
                'UsageFrequency': frequency
            })
    return report

# Save the report to a CSV file
def save_report_to_csv(report, filename="user_role_report.csv"):
    with open(filename, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=['UserName', 'RoleName', 'LastUsed', 'UsageFrequency'])
        writer.writeheader()
        for row in report:
            writer.writerow(row)
    print(f"Report saved to {filename}")

if __name__ == "__main__":
    # Step 1: Generate the user-role report
    report = generate_user_role_report()
    
    # Step 2: Save the report to a CSV file
    save_report_to_csv(report)

#-----------------------------------------------------------------------------------------------------------------

#------------------------------------io_handler.py------------------------------------
import csv
import os

class IOHandler:
    def __init__(self, input_dir='input', output_dir='output'):
        self.input_dir = input_dir
        self.output_dir = output_dir

        # Create directories if they do not exist
        if not os.path.exists(self.input_dir):
            os.makedirs(self.input_dir)
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

    def read_csv(self, filename):
        """Read input data from a CSV file."""
        file_path = os.path.join(self.input_dir, filename)
        data = []
        try:
            with open(file_path, mode='r', newline='', encoding='utf-8') as file:
                csv_reader = csv.DictReader(file)
                for row in csv_reader:
                    data.append(row)
            return data
        except FileNotFoundError:
            print(f"File {file_path} not found. Please ensure the file is in the correct directory.")
            return None
        except Exception as e:
            print(f"Error reading file {filename}: {str(e)}")
            return None

    def write_output(self, filename, content):
        """Write the generated SCD output to a text file."""
        file_path = os.path.join(self.output_dir, filename)
        try:
            with open(file_path, mode='w', encoding='utf-8') as file:
                file.write(content)
            print(f"Output successfully written to {file_path}")
        except Exception as e:
            print(f"Error writing to file {filename}: {str(e)}")

    def get_user_input(self, prompt_text):
        """Interact with user to get dynamic input."""
        return input(prompt_text)

    def list_input_files(self):
        """List available CSV files in the input directory."""
        files = [f for f in os.listdir(self.input_dir) if f.endswith('.csv')]
        if not files:
            print(f"No CSV files found in {self.input_dir}")
        return files

    def display_data(self, data):
        """Pretty print the loaded data."""
        for index, row in enumerate(data, start=1):
            print(f"Record {index}: {row}")

 #--------------------------------------------------__-------------------------------------------------


#----------------------------------ai playground request------------------------------------------------
import requests
import json

# Replace with your deployed AI model URL
AI_MODEL_URL = "https://your-deployed-ai-model-url.com/api"

# Define the payload data
payload = {
    "system_prompt": "Your system prompt here",
    "user_prompt": "Your user prompt here",
    "user_query": "Your user query here",
    "parsed_content": "Your parsed content here",
    "document": None  # Placeholder for your document dataset
}

# Specify headers for the request
headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer YOUR_API_KEY_HERE",  # Replace with your API key or token if required
}

# Function to send POST request with JSON payload and document
def send_request_with_document(document_path=None):
    if document_path:
        # If a document is provided, read it and include it in the payload
        with open(document_path, 'r') as file:
            document_data = file.read()
        payload["document"] = document_data

    # Send the POST request
    response = requests.post(AI_MODEL_URL, headers=headers, data=json.dumps(payload))

    # Check the response
    if response.status_code == 200:
        print("Request successful!")
        print("Response:", response.json())
    else:
        print(f"Request failed with status code {response.status_code}")
        print("Response:", response.text)

# Example usage
document_path = "path/to/your/document.txt"  # Replace with the actual document file path
send_request_with_document(document_path)

#-------------------------------------------------------------------------------------------------------------
pip install google-api-python-client google-auth google-cloud-logging google-cloud-resourcemanager

import os
import datetime
from google.auth import default
from googleapiclient.discovery import build
from google.cloud import logging_v2

# Define time threshold (3 months ago)
time_threshold = datetime.datetime.utcnow() - datetime.timedelta(days=90)

# Authentication using default credentials (e.g., service account)
credentials, project_id = default()

# Initialize the IAM and Logging services
iam_service = build('iam', 'v1', credentials=credentials)
logging_client = logging_v2.Client()

# List all users and their assigned roles (bindings)
def list_iam_roles():
    roles_to_check = []
    request = iam_service.projects().getIamPolicy(resource=project_id, body={})
    policy = request.execute()
    
    for binding in policy['bindings']:
        role = binding['role']
        members = binding.get('members', [])
        for member in members:
            if member.startswith('user:'):  # Only checking user accounts
                roles_to_check.append({'user': member, 'role': role})
    
    return roles_to_check

# Query Cloud Logging for the role usage (fetch IAM policy changes)
def check_role_usage(user_email, role):
    #filter_str = f"""
   # protoPayload.authenticationInfo.principalEmail="{user_email}" AND\
  #  protoPayload.serviceName="iam.googleapis.com" AND\
  #  protoPayload.methodName="SetIamPolicy" AND\
 #   protoPayload.authorizationInfo.resource="projects/{project_id}" AND\
 #   resource.labels.role="{role}"\"""
    
    usage_found = False
    last_used = None

    for entry in logging_client.list_entries(filter_=filter_str):
        log_time = entry.timestamp
        
        if log_time and log_time > time_threshold:
            last_used = log_time
            usage_found = True
            break

    return last_used if usage_found else None

# Revoke unused roles by updating IAM policy
def revoke_unused_roles(unused_roles):
    policy = iam_service.projects().getIamPolicy(resource=project_id, body={}).execute()
    bindings = policy['bindings']

    # Filter out unused roles from the policy
    for unused_role in unused_roles:
        for binding in bindings:
            if binding['role'] == unused_role['role'] and unused_role['user'] in binding['members']:
                binding['members'].remove(unused_role['user'])
                print(f"Revoked {unused_role['role']} from {unused_role['user']}")
                break

    # Update the IAM policy
    body = {'policy': policy}
    iam_service.projects().setIamPolicy(resource=project_id, body=body).execute()

# Main function
def main():
    roles = list_iam_roles()
    unused_roles = []

    # Check last usage of each role
    for role in roles:
        user = role['user']
        assigned_role = role['role']
        last_used = check_role_usage(user, assigned_role)
        
        if last_used is None:
            print(f"Role {assigned_role} assigned to {user} has not been used in the last 3 months.")
            unused_roles.append(role)
        else:
            print(f"Role {assigned_role} assigned to {user} was last used on {last_used}.")

    # Revoke unused roles
    if unused_roles:
        revoke_unused_roles(unused_roles)
    else:
        print("No unused roles found.")

if __name__ == "__main__":
    main()
  
#---------------------------------_-----------------------------------------
#https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform
import datetime
import csv
from google.auth import default
from googleapiclient.discovery import build
from google.cloud import logging_v2

# Define time threshold (3 months ago) and make it timezone-aware
time_threshold = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(days=90)

# Authentication using default credentials (e.g., service account)
credentials, project_id = default()

# Initialize the Resource Manager and Logging services
crm_service = build('cloudresourcemanager', 'v1', credentials=credentials)
logging_client = logging_v2.Client()

# List all users and their assigned roles (IAM bindings)
def list_iam_roles():
    roles_to_check = []
    
    # Get the IAM policy for the project
    policy_request = crm_service.projects().getIamPolicy(resource=project_id, body={})
    policy = policy_request.execute()
    
    for binding in policy['bindings']:
        role = binding['role']
        members = binding.get('members', [])
        for member in members:
            if member.startswith('user:'):  # Only checking user accounts
                roles_to_check.append({'user': member, 'role': role})
    
    return roles_to_check

# Query Cloud Logging for the role usage (fetch IAM policy changes)
def check_role_usage(user_email, role):
 
    
    usage_found = False
    last_used = None

    for entry in logging_client.list_entries(filter_=filter_str):
        log_time = entry.timestamp
        
        # Ensure log_time is timezone-aware
        if log_time.tzinfo is None:
            log_time = log_time.replace(tzinfo=datetime.timezone.utc)

        if log_time and log_time > time_threshold:
            last_used = log_time
            usage_found = True
            break

    return last_used if usage_found else None

# Write the results to a CSV file
def write_to_csv(data, filename='role_usage_report.csv'):
    with open(filename, mode='w', newline='') as csvfile:
        fieldnames = ['User', 'Role', 'Last Used', 'Status']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

        # Write the header
        writer.writeheader()

        # Write the data rows
        for row in data:
            writer.writerow(row)

    print(f"Report written to {filename}")

# Revoke unused roles by updating IAM policy
def revoke_unused_roles(unused_roles):
    # Get the current IAM policy for the project
    policy_request = crm_service.projects().getIamPolicy(resource=project_id, body={})
    policy = policy_request.execute()
    
    bindings = policy['bindings']

    # Filter out unused roles from the policy
    for unused_role in unused_roles:
        for binding in bindings:
            if binding['role'] == unused_role['role'] and unused_role['user'] in binding['members']:
                binding['members'].remove(unused_role['user'])
                print(f"Revoked {unused_role['role']} from {unused_role['user']}")
                break

    # Update the IAM policy to remove unused roles
    body = {'policy': policy}
    crm_service.projects().setIamPolicy(resource=project_id, body=body).execute()

# Main function
def main():
    roles = list_iam_roles()
    unused_roles = []
    csv_data = []

    # Check last usage of each role
    for role in roles:
        user = role['user']
        assigned_role = role['role']
        last_used = check_role_usage(user, assigned_role)

        if last_used is None:
            print(f"Role {assigned_role} assigned to {user} has not been used in the last 3 months.")
            unused_roles.append(role)
            csv_data.append({
                'User': user,
                'Role': assigned_role,
                'Last Used': 'Never Used',
                'Status': 'To be revoked'
            })
        else:
            print(f"Role {assigned_role} assigned to {user} was last used on {last_used}.")
            csv_data.append({
                'User': user,
                'Role': assigned_role,
                'Last Used': last_used.strftime('%Y-%m-%d %H:%M:%S'),
                'Status': 'Active'
            })

    # Write to CSV
    write_to_csv(csv_data)

    # Revoke unused roles
    if unused_roles:
        revoke_unused_roles(unused_roles)
    else:
        print("No unused roles found.")

if __name__ == "__main__":
    main()
    
#--------------------------------------------------------------------------------
import os
import google.auth
from google.auth.transport.requests import Request
from google.auth import impersonated_credentials
from google.oauth2 import service_account
from googleapiclient.discovery import build
from requests.exceptions import HTTPError
import time

# Retry logic for token refresh
def refresh_credentials_with_retry(credentials, max_retries=3, delay=2):
    for i in range(max_retries):
        try:
            credentials.refresh(Request())
            return credentials
        except HTTPError as e:
            if i < max_retries - 1:
                time.sleep(delay)
                delay *= 2  # Exponential backoff
            else:
                raise e

# Set up impersonated credentials
def get_impersonated_credentials():
    service_account_credentials = service_account.Credentials.from_service_account_file(
        'your-service-account.json',
        scopes=['https://www.googleapis.com/auth/cloud-platform']
    )
    
    target_principal = os.environ.get('TARGET_SERVICE_ACCOUNT')  # Target service account to impersonate
    
    # Create impersonated credentials
    credentials = impersonated_credentials.Credentials(
        source_credentials=service_account_credentials,
        target_principal=target_principal,
        target_scopes=['https://www.googleapis.com/auth/cloud-platform']
    )
    
    # Refresh the impersonated credentials with retry logic
    return refresh_credentials_with_retry(credentials)

# Use impersonated credentials to make API calls
def list_iam_roles():
    try:
        # Get impersonated credentials
        credentials = get_impersonated_credentials()
        
        # Initialize Resource Manager API with impersonated credentials
        crm_service = build('cloudresourcemanager', 'v1', credentials=credentials)
        project_id = os.environ.get("PROJECT_ID")
        
        # Get IAM policy for the project
        policy_request = crm_service.projects().getIamPolicy(resource=project_id, body={})
        policy = policy_request.execute()

        # List roles and members
        roles_to_check = []
        for binding in policy.get('bindings', []):
            role = binding['role']
            members = binding.get('members', [])
            for member in members:
                if member.startswith('user:'):  # Only check user accounts
                    roles_to_check.append({'user': member, 'role': role})

        return roles_to_check

    except Exception as e:
        print(f"Error occurred: {str(e)}")
        return []

# Example usage
roles = list_iam_roles()
print(roles)
#--------------------------------------------------------------------------
from google.auth import default
from googleapiclient.discovery import build
import time
import logging
from googleapiclient.errors import HttpError

logging.basicConfig(level=logging.DEBUG)

# Get default credentials and project ID
credentials, project_id = default()

# Initialize the Cloud Resource Manager service
crm_service = build('cloudresourcemanager', 'v1', credentials=credentials)

# Function to get IAM policy with retry logic
def get_iam_policy_with_retry(project_id, max_retries=3):
    attempts = 0
    while attempts < max_retries:
        try:
            request = crm_service.projects().getIamPolicy(resource=project_id, body={})
            response = request.execute()  # Execute the request
            return response  # Return the response if successful
        except HttpError as e:
            print(f"Attempt {attempts + 1} failed: {str(e)}")
            attempts += 1
            time.sleep(2 ** attempts)  # Exponential backoff after failure
    
    raise Exception("Failed to retrieve IAM policy after multiple attempts")

# Main function to retrieve and print the IAM policy
def main():
    try:
        policy = get_iam_policy_with_retry(project_id)
        print("IAM Policy:", policy)
    except Exception as e:
        print(f"Error retrieving IAM policy: {str(e)}")

if __name__ == "__main__":
    main()
#----------------------------------_------------------------------
AWS Role-Wise Usage Report - Description
The AWS Role-Wise Usage Report is designed to provide a comprehensive view of the IAM roles assigned to users within an AWS account, detailing how frequently each role has been utilized in the last 90 days (3 months). The report is intended to help administrators and security teams audit the usage of IAM roles, identify inactive or underused roles, and optimize access management by revoking unused permissions to enhance security.

The report includes the following key information:

1. User Information
User Name: The name of the IAM user assigned a particular role.
User ARN (Amazon Resource Name): A globally unique identifier that specifies the AWS account and user.
2. Role Information
Role Name: The name of the IAM role assigned to the user.
Role ARN: The unique identifier for the IAM role that provides the user specific permissions.
3. Last Role Usage
Last Used Date: The most recent date when the IAM role was used by the user. This field helps identify if the role has been actively used or remains dormant.
Usage Frequency: The total number of times the user has assumed or used the IAM role within the last 90 days. Higher usage indicates frequent reliance on the role, whereas low or zero usage signals inactivity.
4. Usage Status
Active Roles: Roles that have been actively used by users within the last 90 days. These roles are essential for user operations and should be retained.
Inactive Roles: Roles that have not been used in the last 90 days. These roles are candidates for review and potential revocation to minimize security risks and enforce the principle of least privilege.
5. Recommendations
For each role that hasn't been used in the past 90 days, the report will include a recommendation to revoke or deactivate the role from the assigned user to improve security posture.
For frequently used roles, the report may recommend role consolidation or review of attached policies to ensure that only necessary permissions are granted.
Usage Insights:
Date Range: The report covers data from the last 90 days (3 months), providing an accurate snapshot of role activity during this period.
Role Management: The report helps AWS administrators easily manage IAM roles by highlighting active and inactive roles, optimizing access control, and ensuring unused permissions are not left in the environment.
Security Enhancement: Regular review of role assignments and usage helps secure the AWS environment by reducing the risk of over-provisioned access.
#-----------------------------------------------------------------------
AWS Role-Wise Usage Report - Python Script Documentation
Introduction:
This Python script is designed to generate a detailed report of IAM roles assigned to users in an AWS account and their usage patterns over the past 90 days. It utilizes AWS Boto3 SDK to interact with IAM and CloudTrail services. The output is a CSV file listing each user, their assigned roles, the last time the role was used, and how frequently the role has been utilized in the last 3 months. The report is helpful for auditing, identifying inactive roles, and improving security by revoking unnecessary roles.

Requirements:
AWS credentials with permissions to access IAM and CloudTrail services.
Python environment with boto3 library installed.
You can install boto3 using the following command:

bash
Copy code
pip install boto3
Functions:
1. list_users()
Purpose: Retrieve a list of all IAM users in the AWS account.
Description: Uses the IAM list_users API to paginate through all users in the account and return them in a list.
Returns:
A list of dictionaries, where each dictionary contains details of an IAM user (e.g., UserName, UserId, Arn, etc.).
Usage:
python
Copy code
users = list_users()
Exception Handling: Captures any errors in retrieving users and prints an error message.
2. get_user_roles(user_name)
Purpose: Get all roles assigned to a specific IAM user through attached policies.
Description: Retrieves attached policies for the user and parses the policy document to check if the user has permissions to assume any roles (through the AssumeRole action).
Parameters:
user_name: The name of the IAM user whose roles are to be checked.
Returns:
A list of roles assigned to the user (i.e., role ARNs).
Usage:
python
Copy code
roles = get_user_roles(user_name)
Exception Handling: Handles any issues retrieving roles for a user and outputs an error message.
3. get_role_usage(role_name)
Purpose: Determine when a specific IAM role was last used and how often it was used in the past 90 days.
Description: Uses CloudTrail's lookup_events API to query for AssumeRole events associated with a particular role over the last 3 months.
Parameters:
role_name: The ARN of the IAM role whose usage is being checked.
Returns:
last_used: The most recent time the role was used (or None if never used in the time period).
frequency: The number of times the role has been assumed in the past 90 days
Usage:
python
Copy code
last_used, frequency = get_role_usage(role_name)
Exception Handling: Captures any errors during the CloudTrail query and prints an error message.
4. generate_user_role_report()
Purpose: Generate a detailed report containing all users, their roles, and role usage information.
Description: Iterates through all IAM users, retrieves their assigned roles, checks each role's usage via CloudTrail, and compiles the data into a list of dictionaries.
Returns:
A list of dictionaries where each dictionary contains:
UserName: IAM user name.
RoleName: IAM role ARN.
LastUsed: Date when the role was last used or 'Never' if unused.
UsageFrequency: The number of times the role was used in the last 90 days.
Usage:
python
Copy code
report = generate_user_role_report()
5. save_report_to_csv(report, filename="user_role_report.csv")
Purpose: Save the generated report to a CSV file.
Description: Writes the user-role report to a CSV file with appropriate headers. Each row contains the user, role, last usage date, and usage frequency.
Parameters:
report: The list of dictionaries returned by generate_user_role_report().
filename (optional): The name of the CSV file to save the report. Defaults to user_role_report.csv.
Returns:
Saves the CSV file to the local file system and prints a confirmation message.
Usage:
python
Copy code
save_report_to_csv(report)
CSV Report Details:
The generated CSV report provides the following columns:

UserName: The name of the IAM user.
RoleName: The ARN of the IAM role assigned to the user.
LastUsed: The most recent date the role was used by the user. Displays 'Never' if the role wasn't used in the last 90 days.
UsageFrequency: The number of times the user has assumed or used the role within the past 90 days.
Sample Output (CSV File):
UserName	RoleName	LastUsed	UsageFrequency
john.doe	arn:aws:iam::123456789012
/AdminRole	2023-06-10	10
jane.smith	arn:aws:iam::123456789012
/ReadOnlyRole	Never	0
Example Usage:
Set up AWS credentials in your environment (e.g., by using aws configure or providing a credentials file).
Run the Python script to generate the report:
bash
Copy code
python aws_role_usage_report.py
The script will generate a CSV file named user_role_report.csv in the current directory.

Sample Output (CSV File):
UserName	RoleName	LastUsed	UsageFrequency
john.doe	arn:aws:iam::123456789012
/AdminRole	2023-06-10	10
jane.smith	arn:aws:iam::123456789012
/ReadOnlyRole	Never	0

----_-_-_-_--_-_-__&_--_-_-_-_&-_-_-_-_-_-__-_--_-_-_-_-_-_-_-__-_-_-___-_-_-_-_-_-_-_-_-_
import os

import datetime

from google.auth.transport.requests import Request

from google.auth import default

from google.auth import impersonated_credentials

from google.oauth2 import service_account

from requests.exceptions import HTTPError from googleapiclient.discovery import build

from google.cloud import logging_v2

from dotenv import load_dotenv

Import requests

Import esv

import requests

from googleapiclient.errors import HttpError

#request google.auth.transport.requests.Request()

load_dotenv()

#Define time threshold (90 days)

time_threshold datetime.datetime.now(datetime.timezone.utc) datetime.timedelta(days-days)

days - 90

#Authentication using default credentials (e.g., service account)

credentials, project_id default()

#credentials.refresh(request)

project_id = os.environ.get("GCP_PROJECT_ID")

project_id -

Initialize Logging services

cra_service build("cloudresourcemanager", "v1", credentials-credentials)

logging client logging v2.Client()

#List all users and their assigned roles (bindings)

def list_iam_roles():
def list_iam_roles():

#request lan_service.projects().getIamPolicy(resource-project_id, body-())

roles_to_check[]

try:

policycra service.projects().getIamPolicy(resource-project_id, body-()).execute() # Execute the request

policy request.execute()

print("policy: ", policy)

14 policy:

for binding in policy["bindings"]:

role binding "role"]

members binding.get("members", [])

for member in members:

#print("members:", member)

I

1f member.startswith("user:"): Only checking user accounts

roles_to_check.append({"user": member, "role": role))

return roles_to_check

except HttpError as e:

print(f"failed: {str(e)}")

raise Exception("Failed to retrieve IAM policy after multiple attempts")

Query Cloud Logging for the role usage (fetch IAM policy changes)

def check_role_usage():

usage found False

last used fione

for entry in logging_client.list_entries():

log time entry.timestamp

if log time.tzinfo is None:

log time log time.replace(tzinfo-datetime.timezone.utc)
if log time:

last used log time

usage found True

break

return last used if usage found else None

I

def write to csv(data, filename='user_role_report.csv'): with open(filename, node 'a', newline-") as csvfile: Fieldnames= ['User', 'Role', 'Last Used', 'Status'] writer = csv.DictWriter(csvfile, fieldnames-fieldnames)

#Write the header writer.writeheader()

#Write the data rows for row in data: writer.writerow(row)

print(f"Report written to {filename}")

#Main function

def main(): roles list_iam_roles() unused roles [] csv data-[]

#Check last usage of each role
#Check last usage of each role

For role in roles:

user = rolet "user"]

assigned role role["role"]

I

})

last used check_role_usage()

if last used is None:

unused_roles.append(role)

csv_data.append({

'User': user,

"Role': assigned_role,

"Last Used': 'Never Used",

"Status': 'To be revoked'

else:

csv_data.append({

"User': user,

"Role': assigned_role,

"Last Used': last_used.strftime('%Y-%m-%d %H:%M:%S'),

'Status': 'Active'

})

#Write to CSV

write_to_csv(csv_data)

fname"main":

main()


_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
GCP Role Usage Report - Python Script Documentation
Introduction:
This document provides an overview of the Python script used to generate a GCP IAM role usage report. The script checks for the usage of roles assigned to users over the past 90 days and records the findings in a CSV file. Roles that have not been used during this period are flagged as "To be revoked."

Key Functions:
list_iam_roles():

Description: Retrieves a list of all IAM roles assigned to users in a GCP project by fetching the IAM policy.
Output: A list of dictionaries containing user-role mappings.
Parameters: No parameters.
Example Output:
python
Copy code
[{'user': 'user1@example.com', 'role': 'roles/owner'}, 
 {'user': 'user2@example.com', 'role': 'roles/editor'}]
check_role_usage(user_email, role):

Description: Queries GCP Cloud Logging to check when a role was last used by a specific user.
Input:
user_email: Email of the user to check.
role: The assigned IAM role.
Output: The last usage time of the role or None if no usage is found within the last 90 days.
Return: datetime of last usage or None.
write_to_csv(data, filename='user_role_report.csv'):

Description: Writes the role usage data to a CSV file. It includes user, role, last used date, and the status of the role.
Input:
data: A list of dictionaries containing the user, role, last used date, and status (active or to be revoked).
filename: Name of the CSV file (default: user_role_report.csv).
Output: A CSV file with role usage data.
Example CSV Content:
plaintext
Copy code
User,Role,Last Used,Status
user1@example.com,roles/owner,2023-09-15 10:34:45,Active
user2@example.com,roles/editor,Never Used,To be revoked
main():

Description: Main function that combines the role retrieval, usage checking, and CSV writing.
Process:
Fetches all IAM roles assigned to users using list_iam_roles().
For each role, it checks if the role was used within the last 90 days using check_role_usage().
Stores the results in a CSV with columns for the user, role, last used time, and status.
Output: Generates a CSV report with role usage information.


CSV Report Structure:
The CSV file generated by this script includes the following fields:

User: The email address of the user associated with the role.
Role: The IAM role assigned to the user.
Last Used: The last date and time when the role was used. If the role was never used in the last 90 days, this field will show "Never Used."
Status: Either "Active" (if the role was used in the past 90 days) or "To be revoked" (if the role was not used).
How to Use:
Pre-requisites:

Set up Google Cloud SDK and authenticate using service account credentials.
Install the required Python libraries (google-auth, google-api-python-client, google-cloud-logging).
Running the script:

Execute the script in a GCP project environment. It will generate a user_role_report.csv file, storing role usage data for all users in the project.
Reviewing the report:

Open the generated CSV file to review the roles, their last used time, and whether they are flagged for revocation based on inactivity.
-_-_-__-__---_-_-_--_-_-_-_-----__-_&-_--_-_-_-_-_-_-_--_-_-_-_-_-_-_-_-_-_-_-_--_-_-_-_-_-_-_--_-_-_-_-_-_-_-_-_--_-_-_-_-_

AWS IAM Role Usage Report and GitHub Action Pipeline
This repository provides a Python script to generate an AWS IAM role usage report and a corresponding GitHub Actions pipeline for automated execution. The Python script lists all AWS IAM users, retrieves the roles they have used, and generates a CSV report with the most frequently used roles in the past 90 days. The GitHub Actions workflow automates this process, including running a SonarQube scan and leveraging OIDC for secure authentication with AWS.

Table of Contents
Overview
Python Script Description
Requirements
Script Breakdown
GitHub Actions Workflow
Prerequisites
Workflow Breakdown
How to Trigger the Workflow
Generating the Report
SonarQube Integration
How to Set Up
AWS OIDC Authentication
Run Locally
Overview
The purpose of this project is to track IAM role usage in your AWS account and generate a report of user activity over the last 90 days. This project is automated using GitHub Actions, so you can easily execute the script and store results in your repository.

The workflow also includes a SonarQube scan to ensure code quality as part of your CI pipeline. Authentication to AWS is handled using OIDC, allowing secure, token-based authentication.

Python Script Description
The Python script, located at generate_iam_report.py, performs the following tasks:

Lists all IAM users in your AWS account.
Retrieves attached policies and IAM roles associated with each user.
Checks CloudTrail logs to find the frequency and last usage of each role for the past 90 days.
Generates a CSV report listing users, roles, the last time the role was used, and usage frequency.
Requirements
Ensure you have the following installed before running the script:

Python 3.7+
boto3 (AWS SDK for Python)
AWS Credentials configured for your environment (for local execution).
Install the required dependencies using:
pip install boto3
Script Breakdown
Functions:
list_users():

Lists all IAM users in the account.
Uses the AWS IAM API to fetch the list.
get_user_roles(user_name):

Retrieves the roles attached to a specific IAM user.
Parses through the attached policies to identify AssumeRole permissions.
get_role_usage(role_name):

Searches CloudTrail logs for AssumeRole events to determine when the role was last used and how often.
generate_user_role_report():

Aggregates the users and their associated role usage into a report.
save_report_to_csv():

Saves the report to a CSV file for further analysis.
How to Run
Run the script locally:

bash
Copy code
python generate_iam_report.py
The script generates a file named user_role_report.csv in the root directory, which contains the following fields:

UserName: Name of the IAM user.
RoleName: The name of the IAM role assigned to the user.
LastUsed: The last date the role was used or "Never" if not used in the last 90 days.
UsageFrequency: How many times the role was used in the last 90 days.
GitHub Actions Workflow
The GitHub Actions pipeline automates the process of running the IAM role usage script and performing code quality checks with SonarQube. Below is the breakdown of each step in the GitHub Action.

Prerequisites
GitHub OIDC configuration for secure AWS authentication.
SonarQube server URL and token to run the code scan.
The required AWS IAM roles for the OIDC authentication (configured in the AWS account).
Workflow Breakdown
The GitHub Action pipeline is defined in the file github-action.yml. Below is a breakdown of the stages:
Key Steps
Checkout Repository:

This step checks out the GitHub repository code so that the workflow can access the Python script and other resources.
Set Up Python:

Sets up Python 3.9 in the GitHub Actions runner environment.
Install Dependencies:

Installs boto3, the required Python package to interact with AWS APIs.
Configure AWS OIDC Login:

Authenticates with AWS using OpenID Connect (OIDC). This step assumes an IAM role in AWS with the necessary permissions to query IAM and CloudTrail.
SonarQube Scan:

Runs a SonarQube scan to check the code for quality, vulnerabilities, and bugs. Requires the SonarQube server token and URL, which are configured as GitHub secrets.
Run Python Script:

Executes the Python script that generates the IAM role usage report.
Upload CSV Artifact:

After the Python script completes, the generated user_role_report.csv file is uploaded as an artifact to the GitHub Actions tab for download.
How to Trigger the Workflow
Automatic Trigger: The workflow runs automatically when code is pushed to the main branch.
Manual Trigger: You can manually trigger the workflow from the GitHub Actions tab.
Generating the Report
After the workflow finishes, you can download the user_role_report.csv from the "Artifacts" section in the GitHub Actions interface. This report provides details about each IAM user and the roles they have used over the past 90 days.

SonarQube Integration
The repository includes a SonarQube scan to ensure the code follows best practices. SonarQube is configured via GitHub Secrets for SONAR_TOKEN and SONAR_HOST_URL. These values should be added to your GitHub repository's secrets.

How to Set Up
AWS OIDC Authentication
Create an IAM Role in your AWS account to be used by GitHub Actions. Attach the necessary permissions for IAM and CloudTrail.
Configure GitHub OIDC to authenticate with AWS by following the official guide.
Run Locally
To run the script locally, follow these steps:

Set up AWS credentials on your local machine using the AWS CLI or environment variables.
Install dependencies:
bash
Copy code
pip install boto3
Run the Python script:
bash
Copy code
python generate_iam_report.py
The script will generate a user_role_report.csv in the current directory.
